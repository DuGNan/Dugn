# Java基础

## 一、集合框架

**Q:说说你知道的集合框架。**<br>
A: 在Collection接口下的List、Set和Queue。<br>
1、List接口：<br>
1.1、ArrayList：<br>
有序排列，可重复，底层是一个Object类型的数组，初始长度是10，长度不够扩容的时候会变成原来的1.5倍+1，线程不安全。<br>
在扩容的时候就会去进行复制数据，复制、移动的代价都比较高，适合用来做遍历，不适合做删除、插入。<br>
<br>
1.2、LinkedList：有序可重复，底层是双向链表，查询慢，增删块，线程不安全。<br>
用链表来做存储，很适合数的插入和删除，遍历和随机访问的速度都比较慢。它有专门对表头和表尾操作的方法，可以做双向队列、队列和栈来用。<br>
<br>
1.3、Vector:是线程安全的版本的ArrayList,在方法上都加上了synchronized。<br>

2、Set接口:<br>
2.1、HashSet:无序不可重复，底层其实是一个HashMap。<br>
存取数据按照元素的Hash值来计算。如果hash值一样，会接着比较equals方法，只有这两个都相同，才会视为同一个元素。<br>
<br>
2.2、TreeSet:使用二叉树实现的。<br>
每次新增一个元素，都会进行排序，将对象插入到二叉树的指定位置。Integer和String可以直接排序插入，其他类型的需要实现Comparable接口。<br>
<br>
2.3、LinkedHashSet：底层是一个LinkedHashMap。<br>

3、Queue也是Collection接口下的：下面的一些子类，有两端出入的List，用数组或者链表实现。<br>
<br>

4、Map接口下面：<br>
4.1、HashMap：使用的最多，键不可以重复，值可以重复，是一个Hash表，线程不安全，键值都可以是null。<br>
4.2、HashTable：是线程安全的，键值都不可以是null。<br>
4.3、TreeMap:是一个二叉树。键不可以重复，值可以重复。<br>
<br><br>


**Q：聊一聊HashMap。**<br>
A：HashMap，它根据key的hashcode存储数据，能快速定位到value的值。只允许一条记录的key是null,多条记录的value是null。<br>
在Jdk1.7之前是数组+链表的结构。1.8之后又引入了红黑树。<br>
Node是他的一个内部类，实现了Map.Entry接口。其实就是一个键值对。<br>
HashMap是用哈希表来存储的，为了解决哈希冲突，它才用了链地址法，也就是把Kay哈希之后，得到数组下标，把数据放在对应下标元素的链表上。<br>
插入数据的时候会根据hash算法来定位键值对的存储位置，有时候有两个key会定位到相同的位置，就表示发生了哈希碰撞。<br>
减少碰撞的办法要么让hash计算的结果分散均匀，或者是让数组变大。<br>
HashMap就用比较好的hash和扩容机制来解决了hash碰撞的问题。<br>
初始长度是16，负载因子是0.75，也就是当node的个数到了16*0.75 = 12个的时候，就会进行resize扩容。<br>
扩容后的大小是原来的两倍。数组的长度也必须是2的n次方。<br>
当然这也避免不了链表过长，所以在jdk1.8的时候当链表长度大于8的时候，链表就会转为红黑树，来增加查找的效率。<br>
<br>
hash算法：<br>
Hash算法的作用是确定哈希桶数组索引的位置。key的hashcode & (length-1) 来计算下标。<br><br>
put方法的流程大致是：<br>
若哈希桶数组为空就扩容, 不为空，就计算索引，找到存储的位置。<br>
如果这个位置不存在元素就直接插入，如果存在元素就判断value是否一致，一致就覆盖，不一致就判断是不是红黑树结构。<br>
如果是红黑树就直接插入，不是就遍历链表准备插入，如果链表的长度大于8，将链表转换为红黑树在插入，不大于8就插入到链表中。<br>
最后再去判断 ++size 和 数组长度 这两个数据有没有达到扩容的标准，如果达到了就扩容，没有的话插入方法这里才完毕。<br>

扩容原理：<br>
扩容时根据元素的数量和数组的总长度来决定的。<br>
重新计算元素的下标位置，还是用那个算法：key的hashcode & (length-1)。<br>
jdk1.7是头插方式，先插入的最终会被放到链表的尾部。<br>
jdk1.8是尾插的方式，在重新计算索引位置之后，可能会被放到新数组的不同位置。<br>
jdk1.8采用了尾插法的好处是避免了循环链表，在遍历这个链表的时候不会死循环。<br>    
采用头插法，多线程运行扩容程序的时候，put顺序是key1-key2,线程A扩容时候遍历的顺序就是key2-key1，由于头插，key1会在链表的尾部。<br> 
若这个时候线程2再来把key1放到同一个哈希桶中，在扩容好的哈希桶数组上也是用头插法。
因为顺序不能确定就会有...-key1-kay2-key1/...-key2-key1-key2这样的循环链表存在。(_链表的其他节点持有着链表头节点的引用_)<br> 
<br> 
如果使用尾插法，元素的顺序能够固定。哈希桶中的put顺序是key1-key2。key2就会在链表的尾部。<br> 
线程1是扩容的顺序key1-key2的顺序，线程2扩容的时候也就是key1-key2的顺序，在扩容好的哈希桶上也尾插法，会出现 key1-key2-key1.../key2-key1-key2...这样的顺序，
总之是把元素挂到链表的尾部，(_链表上的其他节点不会有链表头节点的引用_)。不会出现循环链表。<br> 
尾插法能够保证扩容前后的链表引用关系。<br>
用16作为初始容量是为了保证元素的分布均匀。<br>
因为hash算法去找数组位置的时候，是通过key的hashcode和数组长度-1做与运算，16刚好是2的幂，二进制都是1。<br>
所以只要kay的hashcode是均匀的，这个算法的结果也就是均匀的，<br>
这个元素分在数组的位置也是均匀的，为了实现均匀分布，所以容量是2的幂。<br>
(这里这种解释有点牵强，2,4,8,32也可以啊，为什么默认会是16呢？可能还是因为2,4,8容易引起扩容,32又可能会占用太多空间。16比较折中。)<br>
再说说负载因子为什么是0.75。因为负载因子这个值是一种空间和时间上的折中值，太小会频繁扩容，浪费空间，太大不及时扩容查询效率会变低。0.75也是一个比较折中的值。<br>
为什么链表转红黑树的阙值是8。在源码中的注释里面说了，实际使用的时候，随机hashcode哈希桶里面节点个数的分布大概服从泊松分布，为8的概率已经很低了，这个链表转为红黑树的阙值才是8。另外长度是0的概率大概有0.6，也就是其实大多数情况下，hash计算后哈希桶上是没有节点存在的。<br>
为什么红黑树转为链表的阙值是6。这是为了防止链表和红黑树之间频繁的转换。假如是7的话，再有一个元素被put进入这个哈希桶，就会再次转变为红黑树，频繁的转换比较耗费性能。<br>
<br>
如果问哈希表，就简单打一下，别给自己挖坑。本题之后斜体内容了解，不要回答，避免被追着问。<br>
哈希表是一种key-value的存储结构，_对比二叉树\红黑树等树形结构在查询时效率高，删除或者添加时候效率低的特点，数组等结构则是查询效率低，才有人想设计一种在查询和插入删除操作时候效率比较折中的结构。_<br>
Hash表的设计思想是使用一种算法对key进行运算，拿到运算的结果就能知道改元素的插入或者查询的位置。一种预先知道value位置的思路。<br>
这就是hash算法，最好的理想情况就是所有key都被算到了不同的位置。<br>
当然再好的hash算法都会出现hash冲突，_解决冲突的办法有很多，开发地址、链地址、公共溢出区方法、再散列。_<br>
_主要的是开放地址和链地址用的比较多，开放地址就是把冲突的元素放到与这个元素相邻的空节点上，在查找的时候使用探测方法。线性探测和随机探测，再哈希......_<br>
Java的HashMap采用的是链地址的办法，也就是把hash冲突的元素组成一个链表。<br>
对此Java7和Java8的处理方法又有点不一样。(抛出问题，头插和尾插。)<br>
_这样回答HashMap，基本就是满分答卷了吧。_<br>
<br><br>


Q:ConcurrentHashMap能说一说吗？
A
   
   
   





  


## 二、

## 三、

## 四、

## 五、