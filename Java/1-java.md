# Java基础

## 一、集合框架

**Q:说说你知道的集合框架。**<br>
A: 在Collection接口下的List、Set和Queue。<br>
1、List接口：<br>
1.1、ArrayList：<br>
有序排列，可重复，底层是一个Object类型的数组，初始长度是10，长度不够扩容的时候会变成原来的1.5倍+1，线程不安全。<br>
在扩容的时候就会去进行复制数据，复制、移动的代价都比较高，适合用来做遍历，不适合做删除、插入。<br>
<br>
1.2、LinkedList：有序可重复，底层是双向链表，查询慢，增删块，线程不安全。<br>
用链表来做存储，很适合数的插入和删除，遍历和随机访问的速度都比较慢。它有专门对表头和表尾操作的方法，可以做双向队列、队列和栈来用。<br>
<br>
1.3、Vector:是线程安全的版本的ArrayList,在方法上都加上了synchronized。<br>

2、Set接口:<br>
2.1、HashSet:无序不可重复，底层其实是一个HashMap。<br>
存取数据按照元素的Hash值来计算。如果hash值一样，会接着比较equals方法，只有这两个都相同，才会视为同一个元素。<br>
<br>
2.2、TreeSet:使用二叉树实现的。<br>
每次新增一个元素，都会进行排序，将对象插入到二叉树的指定位置。Integer和String可以直接排序插入，其他类型的需要实现Comparable接口。<br>
<br>
2.3、LinkedHashSet：底层是一个LinkedHashMap。<br>

3、Queue也是Collection接口下的：下面的一些子类，有两端出入的List，用数组或者链表实现。<br>
<br>

4、Map接口下面：<br>
4.1、HashMap：使用的最多，键不可以重复，值可以重复，是一个Hash表，线程不安全，键值都可以是null。<br>
4.2、HashTable：是线程安全的，键值都不可以是null。<br>
4.3、TreeMap:是一个二叉树。键不可以重复，值可以重复。<br>
<br><br>


**Q：聊一聊HashMap。**<br>
A：HashMap，它根据key的hashcode存储数据，能快速定位到value的值。只允许一条记录的key是null,多条记录的value是null。<br>
在Jdk1.7之前是数组+链表的结构。1.8之后又引入了红黑树。<br>
Node是他的一个内部类，实现了Map.Entry接口。其实就是一个键值对。<br>
HashMap是用哈希表来存储的，为了解决哈希冲突，它才用了链地址法，也就是把Kay哈希之后，得到数组下标，把数据放在对应下标元素的链表上。<br>
插入数据的时候会根据hash算法来定位键值对的存储位置，有时候有两个key会定位到相同的位置，就表示发生了哈希碰撞。<br>
减少碰撞的办法要么让hash计算的结果分散均匀，或者是让数组变大。<br>
HashMap就用比较好的hash和扩容机制来解决了hash碰撞的问题。<br>
初始长度是16，负载因子是0.75，也就是当node的个数到了16*0.75 = 12个的时候，就会进行resize扩容。<br>
扩容后的大小是原来的两倍。数组的长度也必须是2的n次方。<br>
当然这也避免不了链表过长，所以在jdk1.8的时候当链表长度大于8的时候，链表就会转为红黑树，来增加查找的效率。<br>
<br>
hash算法：<br>
Hash算法的作用是确定哈希桶数组索引的位置。key的hashcode & (length-1) 来计算下标。<br><br>
put方法的流程大致是：<br>
若哈希桶数组为空就扩容, 不为空，就计算索引，找到存储的位置。<br>
如果这个位置不存在元素就直接插入，如果存在元素就判断value是否一致，一致就覆盖，不一致就判断是不是红黑树结构。<br>
如果是红黑树就直接插入，不是就遍历链表准备插入，如果链表的长度大于8，将链表转换为红黑树在插入，不大于8就插入到链表中。<br>
最后再去判断 ++size 和 数组长度 这两个数据有没有达到扩容的标准，如果达到了就扩容，没有的话插入方法这里才完毕。<br>

扩容原理：<br>
扩容时根据元素的数量和数组的总长度来决定的。<br>
重新计算元素的下标位置，还是用那个算法：key的hashcode & (length-1)。<br>
jdk1.7是头插方式，先插入的最终会被放到链表的尾部。<br>
jdk1.8是尾插的方式，在重新计算索引位置之后，可能会被放到新数组的不同位置。<br>
jdk1.8采用了尾插法的好处是避免了循环链表，在遍历这个链表的时候不会死循环。<br>    
采用头插法，多线程运行扩容程序的时候，put顺序是key1-key2,线程A扩容时候遍历的顺序就是key2-key1，由于头插，key1会在链表的尾部。<br> 
若这个时候线程2再来把key1放到同一个哈希桶中，在扩容好的哈希桶数组上也是用头插法。
因为顺序不能确定就会有...-key1-kay2-key1/...-key2-key1-key2这样的循环链表存在。(_链表的其他节点持有着链表头节点的引用_)<br> 
<br> 
如果使用尾插法，元素的顺序能够固定。哈希桶中的put顺序是key1-key2。key2就会在链表的尾部。<br> 
线程1是扩容的顺序key1-key2的顺序，线程2扩容的时候也就是key1-key2的顺序，在扩容好的哈希桶上也尾插法，会出现 key1-key2-key1.../key2-key1-key2...这样的顺序，
总之是把元素挂到链表的尾部，(_链表上的其他节点不会有链表头节点的引用_)。不会出现循环链表。<br> 
尾插法能够保证扩容前后的链表引用关系。<br>
用16作为初始容量是为了保证元素的分布均匀。<br>
因为hash算法去找数组位置的时候，是通过key的hashcode和数组长度-1做与运算，16刚好是2的幂，二进制都是1。<br>
所以只要kay的hashcode是均匀的，这个算法的结果也就是均匀的，<br>
这个元素分在数组的位置也是均匀的，为了实现均匀分布，所以容量是2的幂。<br>
(这里这种解释有点牵强，2,4,8,32也可以啊，为什么默认会是16呢？)<br>


   
   
   





  


## 二、

## 三、

## 四、

## 五、