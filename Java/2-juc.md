# Java并发编程

## 一、宏观概念
Q: 多线程有了解吗？什么是线程安全问题？<br>
A: 有。多线程安全问题指的是在多个线程在操作内存中的同一个线程共享数据时，这个数据由于CPU多个线程之间来回切换导致的数据值错乱问题。
<br><br>
Q: 出现多线程安全问题的原因有哪些？<br>
A: 在Java中，根据JMM内存模型，导致线程不安全的原因有三个。<br>
    1、可见性:一个线程对数据修改之后，其他线程不知道这个值已经被修改。<br>
    2、原子性:当一个线程对共享数据操作到一半的时候，刚好CPU切换到其他线程也来操作共享变量，干扰了前一个线程的操作。<br>
    3、有序性:由于Java的编译器在生成字节码文件的时候会对字节码指令进行排序。另外CPU也会对交给它处理的机器指令进行排序优化提升效率，这两种指令的重新排序都会造成数据的安全性问题。<br>
    


## 二、线程、线程池

## 三、volatile

## 四、synchronized
Q:谈谈对synchronized关键字的理解。<br>
A:<br>
一、首先是synchronized的使用，它可以作用在方法、静态方法和代码块上。<br>
当一个普通方法使用synchronized修饰的时候，锁住的是当前对象this。<br>
当一个作用于一个静态方法的时候，锁住的是Class实例，相当于类的一个全局锁，会锁住所有调用该方法的线程。<br>
当一个作用于一个对象实例的时候，锁住的是所有用这个对象为锁的代码块。<br>
<br>
二、其次是synchronized的三个特点。非公平、可重入，和不可中断。<br>
非公平锁:指的是在多线程竞争锁资源的时候，未必是按照先到先得的顺序，能保证更大的吞吐量。synchronized是一种悲观锁思想。<br>
可重入：指的是一个线程获得这个对象的锁资源的时候，再运行到还用这个对象锁住的代码的时候，可以不用继续申请锁资源，直接运行，这样的好处是避免死锁。<br>
不可中断：指的是一个线程获得锁资源之后，另一个线程想要获得这个对象的锁，就必须处于阻塞或者是等待状态，并且后一个线程不能被中断。<br>
synchronized就是属于不可被中断的锁，后面线程的状态是BLOCK阻塞。而Lock对象，如果使用的是lock()方法，也是不可中断的，并且线程的状态是Waiting。
使用trylock()方法的时候，是可以被中断的。<br>
三、还有就是synchronized加锁的原理。<br>
<br>
锁对象不能完成synchronized的加锁操作，他的关联的对象monitor才是真正的锁，这个对象也叫监视器。这个监视器有两个重要的变量，
一个是锁的拥有者是哪一个线程owner,另一个是记录获取锁对象次数的计数器recursions。<br>
每个同步代码块在编译之后都会被编译在monitorenter和monitorexit两个字节码指令之间。分别代表了进入同步代码块和退出。<br>
monitorenter进入的逻辑：当JVM执行某个线程的某个同步方法的monitorenter的时候，回去尝试获取当前对象对应的monitor的所有权。<br>
如果没有线程占用这个monitor，计数器的值是0，代表目前锁对象没有线程拥有，线程就进入monitor,修改计数器和owner的值。<br>
如果线程已经拥有了这个锁对象的monitor,意味着是重入monitor,就会把计数器的值加1。<br>
如果其他线程已经占用了这个monitor,那么当前尝试获取monitor的操作就会被阻塞，直到monitor的计数器变成0，才会重新尝试获取这个monitor的所有权。<br>
monitorexit退出的逻辑：每次退出将计数器的值减一，减到0的时候就退出monitor,其他被这个monitor阻塞的线程就可以去尝试获得这个monitor的所有权。<br>
四、最后是两个细节。一个是同步方法在编译的时候不会产生monitorenter等指令，但是这个方法会被标记成ACC_SYNCHRONIZED,会隐式的调用monitorenter和moniterexit。<br>
另一个细节是，JVM在方法的结束地方和异常表里面都有monitorexit，保证了方法一定能够释放锁，这也是synchronized避免死锁的原因。<br>
<br><br><br>
Q: synchronized的底层处理细节知道吗？<br>
A: 大致知道一点。(别答的太自信，让说锁竞争、锁释放、锁等待的过程就GG)<br>
所有请求锁资源的线程都会被放在一个先进后出的竞争队列中(ContentionList),由于这个队列会被频繁的CAS访问，为了降低这个竞争队列队尾元素的竞争，JVM会将一部分线程移动到EntryList这个队列中。<br>
当Owner线程在释放锁资源之后，竞争队列的一部分线程就会进入到EntryList中，并且指定了一个线程作为OnDeck线程。<br>
OnDeck线程不直接把锁交给OnDeck，而是把竞争锁的权利给OnDeck，OnDeck需要重新竞争锁。<br>
当某一个线程获取到了锁资源的时候，他就成为Owner，没有得到锁资源的线程就继续放在EntryList中。<br>
如果Owner线程被wait()方法阻塞，它就会被转移到WaitSet的阻塞队列中，直到它被唤醒之后，会重新把它放到EntryList中。<br>
<br><br><br>

Q:知道synchronized升级的过程吗？简单说一下。<br>
A:知道一点。<br>
synchronized会有一个： 不加锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁  的过程。<br>
要先说一个对象头的概念。<br>
Java对象由三部分构成，对象头，实例数据和补全数据。其中对象头里面就存储了一些对象自身在运行时的数据。<br>
偏向锁就是偏心的意思，其实就是发现在大多数情况下，总是由同一个线程多次获得锁对象，为了让线程获得锁的代价更低，就引出了偏向锁。<br>
从无锁升级为偏向锁：<br>
当有线程第一次访问同步代码块的时候，就会先把synchronized变成偏向锁。<br>
会先把锁住对象的对象头的标志位设置成01，也就是偏向锁模式。<br>
同时使用CAS操作吧这个获取到锁的线程ID记录在对象头的mark word里面，<br>
操作成功了以后，只要是这个线程进入这个锁的代码块的时候，就可以不就行任何操作，提高效率。<br>
偏向锁释放的时候需要让全部的线程停下来，才能撤销偏向锁，把mark word的标志位修改成00轻量级锁或者01无锁的状态。<br>
偏向锁适用于一个线程反复得到同一把锁的情况，有同步无竞争的程序使用的时候性能最好。<br>

<br>
从偏向锁升级为轻量级锁：<br>
关闭偏向锁或者是多个线程争抢偏向锁的时候都会升级成轻量级锁。<br>
在无锁状态下，也就是偏向锁刚刚推出，没有线程获取到当前锁的时候，<br>
JVM会在当前方法的栈帧中创建一个锁记录的空间Lock record，并且把mark work拷贝到锁记录空间中，<br>
拷贝完成后，线程就会进行CAS操作尝试把锁对象的mork word更新成指向Lock record的指针，成功的话就代表当前线程持有了这个锁，修改标志位，执行代码。<br>
如果失败就表示锁已经被别的线程抢占了，这时候锁就需要升级成重量级的锁，锁对象的标志位就会10，后面等待的线程就会进入阻塞状态。<br>
轻量级锁适用于多个线程交替执行的情况，不争抢，只是依次轮流获取锁的情况。<br>
<br>
最后还有一个锁消除和锁粗化的问题。<br>
锁消除，指的是锁住的对象不会存在多线程竞争问题，synchronized没有必要存在。JIT即时编译器就会把锁消除。<br>
锁粗化：JVM探测到一连串重复的操作中，都有用到monitorenter和monitorexit，就会把同步的范围扩大到这些重复操作的外面去。<br>
<br><br><br>


Q:synchronized和Lock的区别，平时使用synchronized都应该注意什么？<br>
A:区别主要有：<br>
Synchronized是关键字，JVM直接支持。Lock是一个接口。一个是JVM层面的，一个是JDK层面的。<br>
synchronized会自动释放锁，即时抛出异常也会释放，而Lock必须手动释放锁。<br>
synchronized是不可中断的，而Lock使用lock方法是不可中断的，使用trylock是可以中断的。<br>
Lock可以知道当前线程有木有拿点锁，synchronized不可以。<br>
synchronized可以锁住方法和代码块，而Lock只能锁住代码块。<br>
Lock可以使用读锁提高多线程读取数据的效率。<br>
synchronized是非公平锁，使用ReentrantLock可以控制是否公平。<br>
<br>
平时使用synchronized的时候要注意：<br>
1、减少synchronized的范围。代码减少，减少执行时间，减少锁的竞争。可能用轻量级锁或者自旋锁就搞定了，避免升级到重量级锁。 <br>
2、降低synchronized锁的粒度。几个无关功能使用不同的锁对象。比如：linkedBlockQueue在入队和出队的时候使用的就是两把锁。<br>
3、读写分离。读的时候不加锁，写的时候加锁。<br>
<br><br><br>




## 五、AQS框架


